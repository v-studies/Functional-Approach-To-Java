# 13.  비동기 작업
- 자바 8에서 CompletableFuture<T>를 도입하여 비동기 작업을 보다 효율적으로 생성할 수 있게 되었다.
- 기존의 Future<T> 타입을 선언적이고 함수적인 방식으로 개선함. 

### 자바의 Future
```java
ExecutorService executor = Executors.newFixedTreadPool(10) -> 쓰레드 10개까지 가능

Callable<Integer> expensiveTask = () -> { -> Callable<T>는 Supplier<T>와 사용 목적이 유사하지만, Callable<T>는 결과값을 반환하고, 예외를 던질 수 있는 작업을 정의함.
  System.out.println("(task) start");

  TimeUnit.SECONDS.sleep(2); -> 작업을 2초 동안 지연시킴 (InterruptedException 발생 가능)

  System.out.println("(task) done");

  return 42;
};


System.out.println("(main) before submitting the task");


var future = executor.submit(expensiveTask); -> expensiveTask의 계산은 즉시 시작되어 결과값에 반영됨. 

System.out.println("(main) after submitting the task");

var theAnswer = future.get(); -> future.get()은 작업이 완료될 때까지 대기하고, 결과를 반환함. 작업이 완료되지 않았다면 블로킹됨.

System.out.println("(main) after the blocking call future.get()"); 

```

### CompletableFutures로 비동기 파이프라인 구축 

#### 1) 편의 메서드를 이용한 CompletableFutures 생성
   - CompletableFutures<Void> runAsync(Runnable runnable)
   - CompletableFutures<U> supplyAsync(Supplier<U> supplier)
  
```java
//Future<T>

ExecutorService executorService = ForkJoinPool.commonPool();

Future<?> futureRunnalbe = executorService.submit(() -> System.out.println("not returning a value"));

Future<String> futureCallable = executorService.submit(() -> "Hello, Async World !");


// CompletableFuture<T>


CompletableFuture<Void> CompletableFutureRunnalbe = CompletableFuture.runAsync(() -> System.out.println("not returning a value"));

CompletableFuture<String> CompletableFutureSupplier = CompletableFuture.supplyAsync(() -> "Hello, Async World !");

```

Future와 CompletableFuture 인스턴스 생성 방식은 유사하지만, CompletableFuture는 반드시 ExecutorService를 필요로 하지 않는다.

#### 2) 작업 합성 및 결합



