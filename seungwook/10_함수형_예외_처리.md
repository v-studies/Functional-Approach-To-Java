# 함수형 예외 처리

우리는 모두 완벽하고 오류없는 코드를 작성하기를 원하지만, 그것은 불가능하다.

그래서 코드에서 불가피하게 발생하는 문제들을 다루기위한 방법으로 자바는 예외 메커니즘을 도입했다.

## try-catch 블록

```java
try {
	return doCalculation(input);
} catch (ArithmeticException e) {
    this.log.error("Calculation failed", e);
	return null;
}
```

리소스 관리가 필요한 경우 try-with-resources를 사용할 수 있다.

```java
try (var fileReader = new FileReader(file);
        var bufferedReader = new BufferedReader(fileReader)) {
	
        var firstLine = bufferedReader.readLine(); 
        System.out.println(firstLine);
    } catch (IOException e) {
        System.err.println("Couldn't read first lint of " + file);
    }
```

## 예외와 에러의 다양한 유형

### 체크 예외

체크예외는 정상적인 제어 흐름에서 벗어나지만, 외부에서 예측할 수 있으며 가능한 경우 복구할 수 있는 예외를 말한다.

예를들어 파일을 찾을 수 없거나(FileNotFoundException), URL이 잘못된 경우(MalformedURLException)와 같은 상황들은 예상할 수 있으므로

자바에서는 이를 처리하기 위해 catch-or-specify 요구사항을 준수해야 한다.

> Catch-or-Specify
> 
> 1. catch로 예외를 잡는다.
> 
> 2. 메서드 시그니처에서 발생하는 예외 명시한다.

### 언체크 예외

언체크 예외는 예상되지 않으며 대부분 복구할 수 없는 경우에 발생한다.

따라서 이러한 예외들은 catch-or-specify 요구사항에 포함되지 않아서 thorws 키워드로 이를 명시하지 않아도 된다.

### 에러

에러는 일발적으로 처리하거나 예외를 잡아낼 수 없는 심각한 문제를 나타낸다.

예를들어 실행중에 사용 가능한 메모리가 부족하면 OutOfMemoryError가 발생한다.

또한 무한 재귀 호출도 결국 StackOverflowError를 발생시킨다.

## 람다에서의 체크 예외

```java
public static String readString(Path path) throws IOException {
	// ..
}

Stream.of(path1, path2, path3)
    .map(Files::readString) // 함수형 표현식에서는 java.io.IOException이 호환되지 않는다.
    .forEach(System.out::println);
```

map 메서드는 Function<T, R> 인터페이스를 사용하며 Function<T, R> 인터페이스의 apply 메서드는 체크 예외를 던질 수 없도록 설계되었다.

람다 표현식의 간결함을 유지하고자 체크 예외를 처리하지 않도록 설계한것이다.

위에 코드를 해결할 간단한 방법은 try-catch를 사용하는것이다.

```java
Stream.of(path1, path2, path3)
    .map(path -> {
        try {
            return Files.readString(path);
        } catch (IOException e){
            return null;
        }
	})
    .forEach(System.out::println);
```

하지만 스트림 파이프라인 람다의 본래 목적이 퇴색된다.

람다, 메서드 참조, 스트림이나 Optional과 같은 파이프라인이 제공하는 간결함과 명확함을 잃지 않으면서도 예외를 처리할 수 있는 방법이 있다.

* 안전한 메서드 추출
* 언체크 예외
* Sneaky 예외 던지기

이러한 선택지들은 함수형 코드에서 예외 처리를 줄이기 위한 불완전한 해결방법이다.

### 1. 안전한 메서드 추출

```java
String safeReadString(Path path) {
    try {
        return Files.readString(path);
    } catch (IOException e) {
        return null;
    }
}

Stream.of(path1, path2, path3)
    .map(Files::safeReadString)
    .filter(Objects::nonNull)
    .forEach(System.out::println);
```

파이프라인은 한층 더 간결하고 명확해졌다. IOException은 파이프라인의 흐름을 방해하지 않도록 처리되지만, 이러한 방법이 모든 상황에 적합하지는 않다.

이러한 처리는 기존 코드에 대한 또 다른 추상화로 제한되며, 방해되는 제어 흐름 조건을 다시 제어한다.

메서드의 실질적인 호출자인 스트림 연산은 예외 처리에 대한 기회를 얻지 못하게 되어, 처리 과정이 불투명하고 유연하지 않게 된다.

### 2. 언체크 예외

언체크 예외는 체크 예외를 직접 다루지 않고 catch-or-specify 요구 사항을 우회한다.

이 방법은 throws 키워드를 사용하는 특수한 함수형 인터페이스를 활용하여 문제가 되는 람다나 메서드 참조를 래핑한다.

기존의 예외를 캐치하여 언체크 예외를 발생시킨다.

```java
@FunctionalInterface
public interface ThrowingFunction<T, R> extends Function<T, R> {
    R applyThrows(T elem) throws Exception;
	
    @Override
    default R apply(T elem) {
        try {
            return applyThrows(elem);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }
	
    public static <T, R> Function<T, R> uncheck(ThrowingFunction<T, R> fn) {
        return fn::apply;
    }
}
```

* Function은 체크 예외를 던질 수 없으므로 ThrowingFunction을 사용하여 예외를 던질 수 있도록 한다.

* uncheck 정적 메서드는 ThrowingFunction을 일반 Function으로 변환해주는 헬퍼 메서드이다.

* 이 변환 과정에서 applyThrows 메서드를 apply 메서드로 감싸고, 발생할 수 있는 체크 예외를 RuntimeException으로 변환해 던진다.

#### ThrowingFunction 활용

```java
Stream.of(path1, path2, path3)
    .map(ThrowingFunction.uncheck(Files::readString)) // Files::readString 메서드는 Path를 입력받아 String을 반환하므로, Function<Path, String>
    .filter(Objects::nonNull)
    .forEach(System.out::println);
```

### 3. 몰래 던지기
